{"ast":null,"code":"let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = get => get(config);\n    config.write = (get, set, arg) => set(config, typeof arg === \"function\" ? arg(get(config)) : arg);\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nconst hasInitialValue = atom => \"init\" in atom;\nconst isActuallyWritableAtom = atom => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {}).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isPromiseLike = x => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b) => \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = a => \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = atomState => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */new WeakMap();\n  const mountedMap = /* @__PURE__ */new WeakMap();\n  const pendingMap = /* @__PURE__ */new Map();\n  let storeListenersRev2;\n  let mountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    storeListenersRev2 = /* @__PURE__ */new Set();\n    mountedAtoms = /* @__PURE__ */new Set();\n  }\n  const getAtomState = atom => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, next);\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies) => {\n    const dependencies = /* @__PURE__ */new Map();\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && a === atom) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(v => {\n          if (!settled) {\n            settled = true;\n            const prevAtomState = getAtomState(atom);\n            const nextAtomState = setAtomValue(atom, promise, nextDependencies);\n            resolvePromise(promise, v);\n            resolve(v);\n            if ((prevAtomState == null ? void 0 : prevAtomState.d) !== nextAtomState.d) {\n              mountDependencies(atom, nextAtomState, prevAtomState == null ? void 0 : prevAtomState.d);\n            }\n          }\n        }, e => {\n          if (!settled) {\n            settled = true;\n            const prevAtomState = getAtomState(atom);\n            const nextAtomState = setAtomValue(atom, promise, nextDependencies);\n            rejectPromise(promise, e);\n            reject(e);\n            if ((prevAtomState == null ? void 0 : prevAtomState.d) !== nextAtomState.d) {\n              mountDependencies(atom, nextAtomState, prevAtomState == null ? void 0 : prevAtomState.d);\n            }\n          }\n        });\n        continuePromise = next => {\n          if (!settled) {\n            settled = true;\n            next.then(v => resolvePromise(promise, v), e => rejectPromise(promise, e));\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, next => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!force && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(([a, s]) => a === atom || readAtomState(a) === s)) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */new Map();\n    let isSync = true;\n    const getter = a => {\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, () => controller == null ? void 0 : controller.abort());\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = atom => returnAtomValue(readAtomState(atom));\n  const addAtom = atom => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = atom => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = atom => {\n    const dependencyMap = /* @__PURE__ */new Map();\n    const dirtyMap = /* @__PURE__ */new WeakMap();\n    const loop1 = a => {\n      const mounted = mountedMap.get(a);\n      mounted == null ? void 0 : mounted.t.forEach(dependent => {\n        if (dependent !== a) {\n          dependencyMap.set(dependent, (dependencyMap.get(dependent) || /* @__PURE__ */new Set()).add(a));\n          dirtyMap.set(dependent, (dirtyMap.get(dependent) || 0) + 1);\n          loop1(dependent);\n        }\n      });\n    };\n    loop1(atom);\n    const loop2 = a => {\n      const mounted = mountedMap.get(a);\n      mounted == null ? void 0 : mounted.t.forEach(dependent => {\n        var _a;\n        if (dependent !== a) {\n          let dirtyCount = dirtyMap.get(dependent);\n          if (dirtyCount) {\n            dirtyMap.set(dependent, --dirtyCount);\n          }\n          if (!dirtyCount) {\n            let isChanged = !!((_a = dependencyMap.get(dependent)) == null ? void 0 : _a.size);\n            if (isChanged) {\n              const prevAtomState = getAtomState(dependent);\n              const nextAtomState = readAtomState(dependent, true);\n              isChanged = !prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState);\n            }\n            if (!isChanged) {\n              dependencyMap.forEach(s => s.delete(dependent));\n            }\n          }\n          loop2(dependent);\n        }\n      });\n    };\n    loop2(atom);\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = a => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending();\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          storeListenersRev2.forEach(l => l({\n            type: \"async-write\",\n            flushed\n          }));\n        }\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    const flushed = flushPending();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(l => l({\n        type: \"write\",\n        flushed\n      }));\n    }\n    return result;\n  };\n  const mountAtom = (atom, initialDependent) => {\n    var _a;\n    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const onUnmount = atom.onMount((...args) => writeAtom(atom, ...args));\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = atom => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach(a => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    let flushed;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */new Set();\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          const mounted = mountedMap.get(atom);\n          if (mounted && !(\n          // TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach(listener => listener());\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n              flushed.add(atom);\n            }\n          }\n        } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    const flushed = flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(l => l({\n        type: \"sub\",\n        flushed\n      }));\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        storeListenersRev2.forEach(l => l({\n          type: \"unsub\"\n        }));\n      }\n    };\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l, rev) => {\n        if (rev !== 2) {\n          throw new Error(\"The current StoreListener revision is 2.\");\n        }\n        storeListenersRev2.add(l);\n        return () => {\n          storeListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: a => atomStateMap.get(a),\n      dev_get_mounted: a => mountedMap.get(a),\n      dev_restore_atoms: values => {\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        const flushed = flushPending();\n        storeListenersRev2.forEach(l => l({\n          type: \"restore\",\n          flushed\n        }));\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nif ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n  if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n    ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n  }\n  globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n}\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n      console.warn(\"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\");\n    }\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\nexport { atom, createStore, getDefaultStore };","map":{"version":3,"names":["keyCount","atom","read","write","key","config","toString","init","get","set","arg","hasInitialValue","isActuallyWritableAtom","cancelPromiseMap","WeakMap","registerCancelPromise","promise","cancel","catch","finally","delete","cancelPromise","next","resolvePromise","value","status","rejectPromise","e","reason","isPromiseLike","x","then","isEqualAtomValue","a","b","Object","is","v","isEqualAtomError","hasPromiseAtomValue","Promise","isEqualPromiseAtomValue","orig","returnAtomValue","atomState","createStore","atomStateMap","mountedMap","pendingMap","Map","storeListenersRev2","mountedAtoms","import","meta","env","MODE","Set","getAtomState","setAtomState","freeze","prevAtomState","has","resolve","reject","updateDependencies","nextAtomState","nextDependencies","dependencies","changed","forEach","aState","d","console","warn","size","setAtomValue","setAtomValueOrPromise","valueOrPromise","abortPromise","continuePromise","settled","mountDependencies","setAtomError","error","readAtomState","force","Array","from","every","s","isSync","getter","aState2","Error","controller","setSelf","options","signal","AbortController","args","writeAtom","abort","readAtom","addAtom","mounted","mountAtom","canUnmountAtom","l","t","delAtom","unmountAtom","recomputeDependents","dependencyMap","dirtyMap","loop1","dependent","add","loop2","_a","dirtyCount","isChanged","writeAtomState","setter","args2","r","flushed","flushPending","type","result","initialDependent","_","aMounted","onMount","onUnmount","u","prevDependencies","depSet","keys","pending","clear","listener","subscribeAtom","listeners","sub","dev_subscribe_store","rev","dev_get_mounted_atoms","values","dev_get_atom_state","dev_get_mounted","dev_restore_atoms","defaultStore","globalThis","__NUMBER_OF_JOTAI_INSTANCES__","getDefaultStore"],"sources":["C:/React/team_one/.yarn/__virtual__/jotai-virtual-900fafc298/0/cache/jotai-npm-2.3.0-9e47e9bf85-21df579532.zip/node_modules/jotai/esm/vanilla.mjs"],"sourcesContent":["let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, arg) => set(\n      config,\n      typeof arg === \"function\" ? arg(get(config)) : arg\n    );\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b) => \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let storeListenersRev2;\n  let mountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    storeListenersRev2 = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, next);\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies) => {\n    const dependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && a === atom) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(\n          (v) => {\n            if (!settled) {\n              settled = true;\n              const prevAtomState = getAtomState(atom);\n              const nextAtomState = setAtomValue(\n                atom,\n                promise,\n                nextDependencies\n              );\n              resolvePromise(promise, v);\n              resolve(v);\n              if ((prevAtomState == null ? void 0 : prevAtomState.d) !== nextAtomState.d) {\n                mountDependencies(atom, nextAtomState, prevAtomState == null ? void 0 : prevAtomState.d);\n              }\n            }\n          },\n          (e) => {\n            if (!settled) {\n              settled = true;\n              const prevAtomState = getAtomState(atom);\n              const nextAtomState = setAtomValue(\n                atom,\n                promise,\n                nextDependencies\n              );\n              rejectPromise(promise, e);\n              reject(e);\n              if ((prevAtomState == null ? void 0 : prevAtomState.d) !== nextAtomState.d) {\n                mountDependencies(atom, nextAtomState, prevAtomState == null ? void 0 : prevAtomState.d);\n              }\n            }\n          }\n        );\n        continuePromise = (next) => {\n          if (!settled) {\n            settled = true;\n            next.then(\n              (v) => resolvePromise(promise, v),\n              (e) => rejectPromise(promise, e)\n            );\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, (next) => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!force && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(\n        ([a, s]) => a === atom || readAtomState(a) === s\n      )) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */ new Map();\n    let isSync = true;\n    const getter = (a) => {\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(\n        atom,\n        valueOrPromise,\n        nextDependencies,\n        () => controller == null ? void 0 : controller.abort()\n      );\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const dependencyMap = /* @__PURE__ */ new Map();\n    const dirtyMap = /* @__PURE__ */ new WeakMap();\n    const loop1 = (a) => {\n      const mounted = mountedMap.get(a);\n      mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n        if (dependent !== a) {\n          dependencyMap.set(\n            dependent,\n            (dependencyMap.get(dependent) || /* @__PURE__ */ new Set()).add(a)\n          );\n          dirtyMap.set(dependent, (dirtyMap.get(dependent) || 0) + 1);\n          loop1(dependent);\n        }\n      });\n    };\n    loop1(atom);\n    const loop2 = (a) => {\n      const mounted = mountedMap.get(a);\n      mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n        var _a;\n        if (dependent !== a) {\n          let dirtyCount = dirtyMap.get(dependent);\n          if (dirtyCount) {\n            dirtyMap.set(dependent, --dirtyCount);\n          }\n          if (!dirtyCount) {\n            let isChanged = !!((_a = dependencyMap.get(dependent)) == null ? void 0 : _a.size);\n            if (isChanged) {\n              const prevAtomState = getAtomState(dependent);\n              const nextAtomState = readAtomState(dependent, true);\n              isChanged = !prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState);\n            }\n            if (!isChanged) {\n              dependencyMap.forEach((s) => s.delete(dependent));\n            }\n          }\n          loop2(dependent);\n        }\n      });\n    };\n    loop2(atom);\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending();\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          storeListenersRev2.forEach(\n            (l) => l({ type: \"async-write\", flushed })\n          );\n        }\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    const flushed = flushPending();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"write\", flushed })\n      );\n    }\n    return result;\n  };\n  const mountAtom = (atom, initialDependent) => {\n    var _a;\n    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const onUnmount = atom.onMount((...args) => writeAtom(atom, ...args));\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    let flushed;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */ new Set();\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          const mounted = mountedMap.get(atom);\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n              flushed.add(atom);\n            }\n          }\n        } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    const flushed = flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"sub\", flushed })\n      );\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        storeListenersRev2.forEach((l) => l({ type: \"unsub\" }));\n      }\n    };\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l, rev) => {\n        if (rev !== 2) {\n          throw new Error(\"The current StoreListener revision is 2.\");\n        }\n        storeListenersRev2.add(l);\n        return () => {\n          storeListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        const flushed = flushPending();\n        storeListenersRev2.forEach(\n          (l) => l({ type: \"restore\", flushed })\n        );\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nif ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n  if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n    ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n  }\n  globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n}\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n      console.warn(\n        \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n      );\n    }\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}