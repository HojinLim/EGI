{"ast":null,"code":"/**\r\n * Calls a callback function a specified number of times and returns the results in an array.\r\n * @param iterations The number of times to call the callback function.\r\n * @param callback The callback function to call.\r\n * @returns An array containing the results of each callback function call.\r\n * @example\r\n * times(5, (i) => i * 2)\r\n * // Returns [0, 2, 4, 6, 8]\r\n *\r\n */\nvar times = function times(iterations, callback) {\n  // Initialize an empty array to store the results\n  var result = []; // Loop `iterations` number of times, calling the callback function on each iteration\n\n  for (var i = 0; i < iterations; i++) {\n    // Call the callback function with the current index and push the result to the results array\n    result.push(callback(i));\n  } // Return the results array\n\n  return result;\n};\n\n/**\r\n * Maps an item in an array at a specified index to a new value.\r\n * @param array The array to map the item in.\r\n * @param index The index of the item to map.\r\n * @param mapFn A function that maps the item to a new value.\r\n * @returns A new array with the mapped item.\r\n * @example\r\n * const originalArray = [1, 2, 3, 4, 5]\r\n * const mappedArray = mapAt(originalArray, 2, (item) => item * 2)\r\n * // Returns [1, 2, 6, 4, 5]\r\n */\nvar mapAt = function mapAt(array, index, mapFn) {\n  // Check that the index is within the bounds of the array\n  if (index > array.length || index < 0) {\n    throw new Error('Index out of range');\n  } // Get the item at the specified index\n\n  var item = array[index]; // Map the item to a new value using the mapFn function\n\n  var newItem = mapFn(item); // If the new value is the same as the original value, return the original array\n\n  if (newItem === item) {\n    return array;\n  } // Create a new array with the mapped item\n\n  var newArray = array.slice();\n  newArray[index] = mapFn(array[index]);\n  return newArray;\n};\n\n/**\r\n * Gets an item from an array based on a mapped index.\r\n * @param index The index of the item to get.\r\n * @param array The array to get the item from.\r\n * @param indexMapFn A function that maps the index to a new index.\r\n * @returns The item at the mapped index in the array.\r\n * @example\r\n * const array = ['a', 'b', 'c', 'd', 'e']\r\n * const indexMapFn = (index, length) => (index * 2) % length\r\n * getItem(2, array, indexMapFn)\r\n * // Returns 'e'\r\n */\nvar getItem = function getItem(index, array, indexMapFn) {\n  // Map the index to a new index using the indexMapFn function\n  var mappedIndex = indexMapFn(index, array.length); // Return the item at the mapped index in the array\n\n  return array[mappedIndex];\n};\n\n/**\r\n * Generates a sequence of values by applying a given function to an initial value for a specified number of iterations.\r\n * @param iterations The number of iterations to perform.\r\n * @param initialValue The initial value of the sequence.\r\n * @param iteratorFn The function to apply to the initial value and each subsequent value.\r\n * @returns An array containing all the iterations.\r\n * @example\r\n * generateSequence(5, 1, (value) => value * 2)\r\n * // Returns [1, 2, 4, 8, 16]\r\n */\nvar generateSequence = function generateSequence(iterations, initialValue, iteratorFn) {\n  if (iterations < 0) {\n    throw new Error('Iterations must be a positive number');\n  }\n  if (iterations === 0) {\n    return [];\n  }\n  var sequence = [initialValue];\n  var value = initialValue;\n  for (var i = 1; i < iterations; i++) {\n    value = iteratorFn(value);\n    sequence.push(value);\n  }\n  return sequence;\n};\n\n/**\r\n * Maps an index to a cyclic pattern.\r\n * @param index The original index.\r\n * @param length The length of the sequence.\r\n * @returns The mapped index in the cyclic pattern.\r\n * @example\r\n * cyclic(6, 5)\r\n * // Returns 1\r\n */\nvar cyclic = function cyclic(index, length) {\n  // Calculate the mapped index based on the cyclic pattern\n  var normalizedIndex = index % length;\n  return Math.abs(normalizedIndex >= 0 ? normalizedIndex : length + normalizedIndex);\n};\n\n/**\r\n * Maps an index to a palindrome pattern.\r\n * @param index The original index.\r\n * @param length The length of the sequence.\r\n * @returns The mapped index in the palindrome pattern.\r\n * @example\r\n * const length = 5\r\n * const indexes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n * indexes.map((index) => palindrome(index, length))\r\n * // Returns [0, 1, 2, 1, 0, 1, 2, 1, 0, 1]\r\n */\nvar palindrome = function palindrome(index, length) {\n  // Save the length of the sequence in a variable\n  var arraySize = length; // If the sequence has only one element, return 0\n\n  if (arraySize === 1) {\n    return 0;\n  } // Calculate the mapped index based on the palindrome pattern\n\n  var normalizedIndex = index % (2 * arraySize - 2);\n  var id = normalizedIndex >= 0 ? normalizedIndex : 2 * arraySize - 2 + normalizedIndex;\n  if (id < arraySize) {\n    return Math.abs(id);\n  } else {\n    return 2 * arraySize - id - 2;\n  }\n};\n\n/**\r\n * Returns the remainder of dividing the dividend by the divisor, with support for negative dividends.\r\n * @param dividend The dividend to divide.\r\n * @param divisor The divisor to divide by.\r\n * @returns The remainder of dividing the dividend by the divisor.\r\n * @example\r\n * // Basic usage\r\n * modulo(5, 3)\r\n * // Returns 2\r\n *\r\n * // Support for negative dividends\r\n * modulo(-5, -3)\r\n * // Returns 2\r\n *\r\n * // Support for negative divisors\r\n * modulo(-5, 3)\r\n * // Returns -2\r\n *\r\n * // Support for negative dividends and divisors\r\n * modulo(5, -3)\r\n * // Returns -2\r\n *\r\n */\nvar modulo = function modulo(dividend, divisor) {\n  // Compute the remainder of dividing the absolute value of the dividend by the absolute value of the divisor.\n  var remainder = Math.abs(dividend) % Math.abs(divisor); // Compute the sign of the result based on the sign of the dividend and divisor.\n\n  var sign = Math.sign(dividend) * Math.sign(divisor); // Compute the result by adjusting the remainder based on the sign.\n\n  var result = remainder * sign; // Return the result.\n\n  return result;\n};\nvar ruleset110 = [0, 1, 1, 1, 1, 0, 0, 0];\n/**\r\n * Generates a new sequence using a one-dimensional cellular automaton.\r\n * @param sequence The initial sequence.\r\n * @param ruleset The ruleset for the cellular automaton.\r\n * @param boundaryFn The boundary function to use.\r\n * @returns The resulting sequence.\r\n * @example\r\n *\r\n * generateSequence(10, sequence, cellularAutomata)\r\n * // Returns [\r\n * //  [0, 0, 0, 0, 1, 0, 0, 0],\r\n * //  [0, 0, 0, 1, 1, 1, 0, 0],\r\n * //  [0, 0, 1, 1, 0, 0, 1, 0],\r\n * //  [0, 1, 1, 0, 1, 1, 1, 1],\r\n * //  [0, 1, 0, 0, 1, 0, 0, 0],\r\n * //  [1, 1, 1, 1, 1, 1, 0, 0],\r\n * //  [1, 0, 0, 0, 0, 0, 1, 1],\r\n * //  [0, 1, 0, 0, 0, 1, 1, 0],\r\n * //  [1, 1, 1, 0, 1, 1, 0, 1],\r\n * //  [0, 0, 0, 0, 1, 0, 0, 1],\r\n * // ]\r\n *\r\n * @complexity This function has a time complexity of O(n), where n is the length of the input sequence, and\r\n * a space complexity of O(n), where n is the length of the input sequence.\r\n */\n\nvar cellularAutomata = function cellularAutomata(sequence, ruleset, boundaryFn) {\n  if (ruleset === void 0) {\n    ruleset = ruleset110;\n  }\n  if (boundaryFn === void 0) {\n    boundaryFn = cyclic;\n  }\n  var nextSequence = new Array(sequence.length);\n  var len = sequence.length; // Apply the ruleset to each cell in the sequence\n\n  for (var i = 0; i < len; i++) {\n    var left = sequence[boundaryFn(i - 1, len)];\n    var middle = sequence[i];\n    var right = sequence[boundaryFn(i + 1, len)];\n    nextSequence[i] = ruleset[left * 4 + middle * 2 + right];\n  }\n  return nextSequence;\n};\nvar numSort = function numSort(a, b) {\n  return a - b;\n};\n/**\r\n * Generates a Euclidean rhythm sequence.\r\n * @param steps The number of steps in the sequence.\r\n * @param notes The number of notes in the sequence.\r\n * @param rotation The rotation of the sequence (default: 0).\r\n * @returns An array of indices representing the Euclidean rhythm sequence.\r\n * @example\r\n * euclideanSequencer(8, 3, 1)\r\n * // Returns [1, 3, 6]\r\n */\n\nvar euclideanSequencer = function euclideanSequencer(steps, notes, rotation) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n\n  // Check that inputs are positive integers\n  if (steps < 0 || notes < 0) {\n    throw new Error('Inputs must be positive integers');\n  } // Initialize an empty sequence array\n\n  var sequence = []; // Determine the maximum number of notes in the sequence\n\n  var maxNotes = notes > steps ? steps : notes; // Iterate through the number of notes and calculate the index for each note\n\n  for (var i = 0; i < maxNotes; i++) {\n    var index = Math.floor(i * steps / maxNotes); // Calculate the index using the Euclidean algorithm\n\n    sequence.push((index + rotation) % steps); // Add the index to the sequence, with rotation applied\n  } // Sort the sequence in ascending order\n\n  return sequence.sort(numSort);\n};\n\n/**\r\n * Generates a sequence of indices representing the \"silences\" (i.e. rests) in a Euclidean rhythm.\r\n * @param steps The number of steps in the rhythm.\r\n * @param notes The number of notes in the rhythm.\r\n * @param rotation The rotation of the rhythm (default: 0).\r\n * @returns An array of indices representing the silences in the Euclidean rhythm.\r\n * @example\r\n * euclideanSilences(8, 3)\r\n * // Returns [1, 3, 4, 6, 7]\r\n */\n\nvar euclideanSilences = function euclideanSilences(steps, notes, rotation) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n\n  // Generate the Euclidean rhythm sequence using the euclideanSequencer function\n  var noteSequence = euclideanSequencer(steps, notes, rotation); // Initialize an empty silence sequence array\n\n  var silenceSequence = []; // Iterate through each step in the rhythm and add the index to the silence sequence if it is not in the note sequence\n\n  for (var i = 0; i < steps; i++) {\n    if (!noteSequence.includes(i)) {\n      silenceSequence.push(i);\n    }\n  } // Return the silence sequence\n\n  return silenceSequence;\n};\n\n/**\r\n * Splits an array into chunks based on a pattern.\r\n * @param array The array to split.\r\n * @param pattern The pattern to split the array with.\r\n * @returns An array of arrays representing the splits.\r\n * @example\r\n * patternChunks([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3])\r\n * // Returns [[1], [2, 3], [4, 5, 6], [7], [8]]\r\n *\r\n * @remarks\r\n * This function splits the input array into chunks based on the specified pattern. The pattern is an array of\r\n * numbers that determines the size of each chunk. If the pattern is shorter than the input array, it will be\r\n * repeated cyclically. If the pattern is longer than the input array, the remaining elements will be discarded.\r\n */\n\nvar patternChunks = function patternChunks(array, pattern) {\n  var result = [];\n  var _array = [].concat(array);\n  var i = 0;\n  while (_array.length > 0) {\n    result.push(_array.splice(0, getItem(i, pattern, cyclic)));\n    i++;\n  }\n  return result;\n};\n\n/**\r\n * Converts an array of binary digits to an array of indices where the digit is 1.\r\n * @param binary An array of binary digits (0 or 1).\r\n * @returns An array of indices where the digit is 1.\r\n * @example\r\n * binaryToIndices([1, 0, 1, 1, 0, 1])\r\n * // Returns [0, 2, 3, 5]\r\n *\r\n * binaryToIndices([1, 1, 1, 1, 1])\r\n * // Returns [0, 1, 2, 3, 4]\r\n *\r\n * binaryToIndices([0, 0, 0, 0, 0])\r\n * // Returns []\r\n *\r\n */\nvar binaryToIndices = function binaryToIndices(binary) {\n  // Initialize an empty array to store the indices.\n  var indices = []; // Loop through the binary array.\n\n  for (var i = 0; i < binary.length; i++) {\n    // If the digit is 1, add the index to the indices array.\n    if (binary[i] === 1) {\n      indices.push(i);\n    }\n  } // Return the array of indices.\n\n  return indices;\n};\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n/**\r\n * Converts an array of indices to a binary array where the indices are 1 and the other digits are 0.\r\n * @param indices An array of indices.\r\n * @param length The length of the binary array to be returned.\r\n * @returns A binary array where the indices are 1 and the other digits are 0.\r\n * @example\r\n * // Basic usage\r\n * indicesToBinary([0, 2, 4], 5)\r\n * // Returns [1, 0, 1, 0, 1]\r\n *\r\n * // Ignoring negative indices\r\n * indicesToBinary([0, -1, 2, -2, 4], 5)\r\n * // Returns [1, 0, 1, 0, 1]\r\n *\r\n * // Indices outside range are ignored\r\n * indicesToBinary([0, 2, 4, 6], 5)\r\n * // Returns [1, 0, 1, 0, 1]\r\n */\nvar indicesToBinary = function indicesToBinary(indices, length) {\n  // Initialize a binary array of the given length, filled with 0s.\n  var binary = Array(length).fill(0); // Loop through the indices array.\n\n  for (var _iterator = _createForOfIteratorHelperLoose(indices), _step; !(_step = _iterator()).done;) {\n    var index = _step.value;\n\n    // Ignore negative indices.\n    if (index >= 0) {\n      // If the index is within range, set the corresponding digit to 1.\n      if (index < length) {\n        binary[index] = 1;\n      }\n    }\n  } // Return the binary array.\n\n  return binary;\n};\nexport { binaryToIndices, cellularAutomata, cyclic, euclideanSequencer, euclideanSilences, generateSequence, getItem, indicesToBinary, mapAt, modulo, palindrome, patternChunks, times };","map":{"version":3,"names":["times","iterations","callback","result","i","push","mapAt","array","index","mapFn","length","Error","item","newItem","newArray","slice","getItem","indexMapFn","mappedIndex","generateSequence","initialValue","iteratorFn","sequence","value","cyclic","normalizedIndex","Math","abs","palindrome","arraySize","id","modulo","dividend","divisor","remainder","sign","ruleset110","cellularAutomata","ruleset","boundaryFn","nextSequence","Array","len","left","middle","right","numSort","a","b","euclideanSequencer","steps","notes","rotation","maxNotes","floor","sort","euclideanSilences","noteSequence","silenceSequence","includes","patternChunks","pattern","_array","concat","splice","binaryToIndices","binary","indices","indicesToBinary","fill","_iterator","_createForOfIteratorHelperLoose","_step","done"],"sources":["C:\\React\\team_one\\.yarn\\cache\\data-fns-npm-1.1.0-2856372be9-5b5d7eeb76.zip\\node_modules\\data-fns\\src\\lib\\times.ts","C:\\React\\team_one\\.yarn\\cache\\data-fns-npm-1.1.0-2856372be9-5b5d7eeb76.zip\\node_modules\\data-fns\\src\\lib\\mapAt.ts","C:\\React\\team_one\\.yarn\\cache\\data-fns-npm-1.1.0-2856372be9-5b5d7eeb76.zip\\node_modules\\data-fns\\src\\lib\\getItem.ts","C:\\React\\team_one\\.yarn\\cache\\data-fns-npm-1.1.0-2856372be9-5b5d7eeb76.zip\\node_modules\\data-fns\\src\\lib\\generateSequence.ts","C:\\React\\team_one\\.yarn\\cache\\data-fns-npm-1.1.0-2856372be9-5b5d7eeb76.zip\\node_modules\\data-fns\\src\\lib\\cyclic.ts","C:\\React\\team_one\\.yarn\\cache\\data-fns-npm-1.1.0-2856372be9-5b5d7eeb76.zip\\node_modules\\data-fns\\src\\lib\\palindrome.ts","C:\\React\\team_one\\.yarn\\cache\\data-fns-npm-1.1.0-2856372be9-5b5d7eeb76.zip\\node_modules\\data-fns\\src\\lib\\modulo.ts","C:\\React\\team_one\\.yarn\\cache\\data-fns-npm-1.1.0-2856372be9-5b5d7eeb76.zip\\node_modules\\data-fns\\src\\lib\\cellularAutomata.ts","C:\\React\\team_one\\.yarn\\cache\\data-fns-npm-1.1.0-2856372be9-5b5d7eeb76.zip\\node_modules\\data-fns\\src\\lib\\euclideanSequencer.ts","C:\\React\\team_one\\.yarn\\cache\\data-fns-npm-1.1.0-2856372be9-5b5d7eeb76.zip\\node_modules\\data-fns\\src\\lib\\euclideanSilences.ts","C:\\React\\team_one\\.yarn\\cache\\data-fns-npm-1.1.0-2856372be9-5b5d7eeb76.zip\\node_modules\\data-fns\\src\\lib\\patternChunks.ts","C:\\React\\team_one\\.yarn\\cache\\data-fns-npm-1.1.0-2856372be9-5b5d7eeb76.zip\\node_modules\\data-fns\\src\\lib\\binaryToIndices.ts","C:\\React\\team_one\\.yarn\\cache\\data-fns-npm-1.1.0-2856372be9-5b5d7eeb76.zip\\node_modules\\data-fns\\src\\lib\\indicesToBinary.ts"],"sourcesContent":["/**\n * Calls a callback function a specified number of times and returns the results in an array.\n * @param iterations The number of times to call the callback function.\n * @param callback The callback function to call.\n * @returns An array containing the results of each callback function call.\n * @example\n * times(5, (i) => i * 2)\n * // Returns [0, 2, 4, 6, 8]\n *\n */\nexport const times = <T>(iterations: number, callback: (index: number) => T): Array<T> => {\n  // Initialize an empty array to store the results\n  const result: Array<T> = []\n\n  // Loop `iterations` number of times, calling the callback function on each iteration\n  for (let i = 0; i < iterations; i++) {\n    // Call the callback function with the current index and push the result to the results array\n    result.push(callback(i))\n  }\n\n  // Return the results array\n  return result\n}\n","/**\n * Maps an item in an array at a specified index to a new value.\n * @param array The array to map the item in.\n * @param index The index of the item to map.\n * @param mapFn A function that maps the item to a new value.\n * @returns A new array with the mapped item.\n * @example\n * const originalArray = [1, 2, 3, 4, 5]\n * const mappedArray = mapAt(originalArray, 2, (item) => item * 2)\n * // Returns [1, 2, 6, 4, 5]\n */\nexport const mapAt = <T>(array: Array<T>, index: number, mapFn: (item: T) => T): Array<T> => {\n  // Check that the index is within the bounds of the array\n  if (index > array.length || index < 0) {\n    throw new Error('Index out of range')\n  }\n\n  // Get the item at the specified index\n  const item = array[index]\n\n  // Map the item to a new value using the mapFn function\n  const newItem = mapFn(item)\n\n  // If the new value is the same as the original value, return the original array\n  if (newItem === item) {\n    return array\n  }\n\n  // Create a new array with the mapped item\n  const newArray = array.slice()\n  newArray[index] = mapFn(array[index])\n\n  return newArray\n}\n","/**\n * Gets an item from an array based on a mapped index.\n * @param index The index of the item to get.\n * @param array The array to get the item from.\n * @param indexMapFn A function that maps the index to a new index.\n * @returns The item at the mapped index in the array.\n * @example\n * const array = ['a', 'b', 'c', 'd', 'e']\n * const indexMapFn = (index, length) => (index * 2) % length\n * getItem(2, array, indexMapFn)\n * // Returns 'e'\n */\nexport const getItem = <T>(\n  index: number,\n  array: Array<T>,\n  indexMapFn: (index: number, length: number) => number\n): T => {\n  // Map the index to a new index using the indexMapFn function\n  const mappedIndex = indexMapFn(index, array.length)\n\n  // Return the item at the mapped index in the array\n  return array[mappedIndex]\n}\n","/**\n * Generates a sequence of values by applying a given function to an initial value for a specified number of iterations.\n * @param iterations The number of iterations to perform.\n * @param initialValue The initial value of the sequence.\n * @param iteratorFn The function to apply to the initial value and each subsequent value.\n * @returns An array containing all the iterations.\n * @example\n * generateSequence(5, 1, (value) => value * 2)\n * // Returns [1, 2, 4, 8, 16]\n */\nexport const generateSequence = <T>(\n  iterations: number,\n  initialValue: T,\n  iteratorFn: (value: T) => T\n): T[] => {\n  if (iterations < 0) {\n    throw new Error('Iterations must be a positive number')\n  }\n\n  if (iterations === 0) {\n    return []\n  }\n\n  const sequence: T[] = [initialValue]\n  let value = initialValue\n\n  for (let i = 1; i < iterations; i++) {\n    value = iteratorFn(value)\n    sequence.push(value)\n  }\n\n  return sequence\n}\n","/**\n * Maps an index to a cyclic pattern.\n * @param index The original index.\n * @param length The length of the sequence.\n * @returns The mapped index in the cyclic pattern.\n * @example\n * cyclic(6, 5)\n * // Returns 1\n */\nexport const cyclic = (index: number, length: number): number => {\n  // Calculate the mapped index based on the cyclic pattern\n  const normalizedIndex = index % length\n  return Math.abs(normalizedIndex >= 0 ? normalizedIndex : length + normalizedIndex)\n}\n","/**\n * Maps an index to a palindrome pattern.\n * @param index The original index.\n * @param length The length of the sequence.\n * @returns The mapped index in the palindrome pattern.\n * @example\n * const length = 5\n * const indexes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n * indexes.map((index) => palindrome(index, length))\n * // Returns [0, 1, 2, 1, 0, 1, 2, 1, 0, 1]\n */\nexport const palindrome = (index: number, length: number): number => {\n  // Save the length of the sequence in a variable\n  const arraySize = length\n\n  // If the sequence has only one element, return 0\n  if (arraySize === 1) {\n    return 0\n  }\n\n  // Calculate the mapped index based on the palindrome pattern\n  const normalizedIndex = index % (2 * arraySize - 2)\n  const id = normalizedIndex >= 0 ? normalizedIndex : 2 * arraySize - 2 + normalizedIndex\n\n  if (id < arraySize) {\n    return Math.abs(id)\n  } else {\n    return 2 * arraySize - id - 2\n  }\n}\n","/**\n * Returns the remainder of dividing the dividend by the divisor, with support for negative dividends.\n * @param dividend The dividend to divide.\n * @param divisor The divisor to divide by.\n * @returns The remainder of dividing the dividend by the divisor.\n * @example\n * // Basic usage\n * modulo(5, 3)\n * // Returns 2\n *\n * // Support for negative dividends\n * modulo(-5, -3)\n * // Returns 2\n *\n * // Support for negative divisors\n * modulo(-5, 3)\n * // Returns -2\n *\n * // Support for negative dividends and divisors\n * modulo(5, -3)\n * // Returns -2\n *\n */\nexport const modulo = (dividend: number, divisor: number): number => {\n  // Compute the remainder of dividing the absolute value of the dividend by the absolute value of the divisor.\n  const remainder = Math.abs(dividend) % Math.abs(divisor)\n\n  // Compute the sign of the result based on the sign of the dividend and divisor.\n  const sign = Math.sign(dividend) * Math.sign(divisor)\n\n  // Compute the result by adjusting the remainder based on the sign.\n  const result = remainder * sign\n\n  // Return the result.\n  return result\n}\n","import { cyclic } from './cyclic'\n\nexport type CellularAutomataRuleset = [\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number\n]\n// a common rule that generates an interesting balance between chaos and order\nconst ruleset110: CellularAutomataRuleset = [0, 1, 1, 1, 1, 0, 0, 0]\n\nexport type BoundaryFunction = (index: number, length: number) => number\n\n/**\n * Generates a new sequence using a one-dimensional cellular automaton.\n * @param sequence The initial sequence.\n * @param ruleset The ruleset for the cellular automaton.\n * @param boundaryFn The boundary function to use.\n * @returns The resulting sequence.\n * @example\n *\n * generateSequence(10, sequence, cellularAutomata)\n * // Returns [\n * //  [0, 0, 0, 0, 1, 0, 0, 0],\n * //  [0, 0, 0, 1, 1, 1, 0, 0],\n * //  [0, 0, 1, 1, 0, 0, 1, 0],\n * //  [0, 1, 1, 0, 1, 1, 1, 1],\n * //  [0, 1, 0, 0, 1, 0, 0, 0],\n * //  [1, 1, 1, 1, 1, 1, 0, 0],\n * //  [1, 0, 0, 0, 0, 0, 1, 1],\n * //  [0, 1, 0, 0, 0, 1, 1, 0],\n * //  [1, 1, 1, 0, 1, 1, 0, 1],\n * //  [0, 0, 0, 0, 1, 0, 0, 1],\n * // ]\n *\n * @complexity This function has a time complexity of O(n), where n is the length of the input sequence, and\n * a space complexity of O(n), where n is the length of the input sequence.\n */\nexport const cellularAutomata = (\n  sequence: Array<number>,\n  ruleset: CellularAutomataRuleset = ruleset110,\n  boundaryFn: BoundaryFunction = cyclic\n): Array<number> => {\n  const nextSequence = new Array(sequence.length)\n  const len = sequence.length\n\n  // Apply the ruleset to each cell in the sequence\n  for (let i = 0; i < len; i++) {\n    const left = sequence[boundaryFn(i - 1, len)]\n    const middle = sequence[i]\n    const right = sequence[boundaryFn(i + 1, len)]\n    nextSequence[i] = ruleset[left * 4 + middle * 2 + right]\n  }\n\n  return nextSequence\n}\n","const numSort = (a: number, b: number) => a - b\n\n/**\n * Generates a Euclidean rhythm sequence.\n * @param steps The number of steps in the sequence.\n * @param notes The number of notes in the sequence.\n * @param rotation The rotation of the sequence (default: 0).\n * @returns An array of indices representing the Euclidean rhythm sequence.\n * @example\n * euclideanSequencer(8, 3, 1)\n * // Returns [1, 3, 6]\n */\nexport const euclideanSequencer = (steps: number, notes: number, rotation = 0): Array<number> => {\n  // Check that inputs are positive integers\n  if (steps < 0 || notes < 0) {\n    throw new Error('Inputs must be positive integers')\n  }\n\n  // Initialize an empty sequence array\n  const sequence: Array<number> = []\n\n  // Determine the maximum number of notes in the sequence\n  const maxNotes = notes > steps ? steps : notes\n\n  // Iterate through the number of notes and calculate the index for each note\n  for (let i = 0; i < maxNotes; i++) {\n    const index = Math.floor((i * steps) / maxNotes) // Calculate the index using the Euclidean algorithm\n    sequence.push((index + rotation) % steps) // Add the index to the sequence, with rotation applied\n  }\n\n  // Sort the sequence in ascending order\n  return sequence.sort(numSort)\n}\n","import { euclideanSequencer } from './euclideanSequencer'\n\n/**\n * Generates a sequence of indices representing the \"silences\" (i.e. rests) in a Euclidean rhythm.\n * @param steps The number of steps in the rhythm.\n * @param notes The number of notes in the rhythm.\n * @param rotation The rotation of the rhythm (default: 0).\n * @returns An array of indices representing the silences in the Euclidean rhythm.\n * @example\n * euclideanSilences(8, 3)\n * // Returns [1, 3, 4, 6, 7]\n */\nexport const euclideanSilences = (steps: number, notes: number, rotation = 0): Array<number> => {\n  // Generate the Euclidean rhythm sequence using the euclideanSequencer function\n  const noteSequence = euclideanSequencer(steps, notes, rotation)\n\n  // Initialize an empty silence sequence array\n  const silenceSequence: Array<number> = []\n\n  // Iterate through each step in the rhythm and add the index to the silence sequence if it is not in the note sequence\n  for (let i = 0; i < steps; i++) {\n    if (!noteSequence.includes(i)) {\n      silenceSequence.push(i)\n    }\n  }\n\n  // Return the silence sequence\n  return silenceSequence\n}\n","import { cyclic } from './cyclic'\nimport { getItem } from './getItem'\n\n/**\n * Splits an array into chunks based on a pattern.\n * @param array The array to split.\n * @param pattern The pattern to split the array with.\n * @returns An array of arrays representing the splits.\n * @example\n * patternChunks([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3])\n * // Returns [[1], [2, 3], [4, 5, 6], [7], [8]]\n *\n * @remarks\n * This function splits the input array into chunks based on the specified pattern. The pattern is an array of\n * numbers that determines the size of each chunk. If the pattern is shorter than the input array, it will be\n * repeated cyclically. If the pattern is longer than the input array, the remaining elements will be discarded.\n */\nexport const patternChunks = <T>(array: Array<T>, pattern: Array<number>): Array<Array<T>> => {\n  const result: Array<Array<T>> = []\n  const _array = [...array]\n  let i = 0\n\n  while (_array.length > 0) {\n    result.push(_array.splice(0, getItem(i, pattern, cyclic)))\n    i++\n  }\n\n  return result\n}\n","/**\n * Converts an array of binary digits to an array of indices where the digit is 1.\n * @param binary An array of binary digits (0 or 1).\n * @returns An array of indices where the digit is 1.\n * @example\n * binaryToIndices([1, 0, 1, 1, 0, 1])\n * // Returns [0, 2, 3, 5]\n *\n * binaryToIndices([1, 1, 1, 1, 1])\n * // Returns [0, 1, 2, 3, 4]\n *\n * binaryToIndices([0, 0, 0, 0, 0])\n * // Returns []\n *\n */\nexport const binaryToIndices = (binary: Array<number>): Array<number> => {\n  // Initialize an empty array to store the indices.\n  const indices: Array<number> = []\n\n  // Loop through the binary array.\n  for (let i = 0; i < binary.length; i++) {\n    // If the digit is 1, add the index to the indices array.\n    if (binary[i] === 1) {\n      indices.push(i)\n    }\n  }\n\n  // Return the array of indices.\n  return indices\n}\n","/**\n * Converts an array of indices to a binary array where the indices are 1 and the other digits are 0.\n * @param indices An array of indices.\n * @param length The length of the binary array to be returned.\n * @returns A binary array where the indices are 1 and the other digits are 0.\n * @example\n * // Basic usage\n * indicesToBinary([0, 2, 4], 5)\n * // Returns [1, 0, 1, 0, 1]\n *\n * // Ignoring negative indices\n * indicesToBinary([0, -1, 2, -2, 4], 5)\n * // Returns [1, 0, 1, 0, 1]\n *\n * // Indices outside range are ignored\n * indicesToBinary([0, 2, 4, 6], 5)\n * // Returns [1, 0, 1, 0, 1]\n */\nexport const indicesToBinary = (indices: Array<number>, length: number): Array<number> => {\n  // Initialize a binary array of the given length, filled with 0s.\n  const binary: Array<number> = Array(length).fill(0)\n\n  // Loop through the indices array.\n  for (const index of indices) {\n    // Ignore negative indices.\n    if (index >= 0) {\n      // If the index is within range, set the corresponding digit to 1.\n      if (index < length) {\n        binary[index] = 1\n      }\n    }\n  }\n\n  // Return the binary array.\n  return binary\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}