{"ast":null,"code":"import ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\nconst StoreContext = createContext(void 0);\nconst useStore = options => {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nconst Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = useRef();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(StoreContext.Provider, {\n    value: store || storeRef.current\n  }, children);\n};\nconst isPromiseLike = x => typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = ReactExports.use || (promise => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(v => {\n      promise.status = \"fulfilled\";\n      promise.value = v;\n    }, e => {\n      promise.status = \"rejected\";\n      promise.reason = e;\n    });\n    throw promise;\n  }\n});\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(prev => {\n    const nextValue = store.get(atom);\n    if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n      return prev;\n    }\n    return [nextValue, store, atom];\n  }, void 0, () => [store.get(atom), store, atom]);\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  return isPromiseLike(value) ? use(value) : value;\n}\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback((...args) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n      throw new Error(\"not writable atom\");\n    }\n    return store.set(atom, ...args);\n  }, [store, atom]);\n  return setAtom;\n}\nfunction useAtom(atom, options) {\n  return [useAtomValue(atom, options),\n  // We do wrong type assertion here, which results in throwing an error.\n  useSetAtom(atom, options)];\n}\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };","map":{"version":3,"names":["ReactExports","createContext","useContext","useRef","createElement","useReducer","useEffect","useDebugValue","useCallback","getDefaultStore","createStore","StoreContext","useStore","options","store","Provider","children","storeRef","current","value","isPromiseLike","x","then","use","promise","status","reason","v","e","useAtomValue","atom","valueFromReducer","storeFromReducer","atomFromReducer","rerender","prev","nextValue","get","Object","is","delay","unsub","sub","setTimeout","useSetAtom","setAtom","args","import","meta","env","MODE","Error","set","useAtom"],"sources":["C:/React/team_one/.yarn/__virtual__/jotai-virtual-900fafc298/0/cache/jotai-npm-2.3.0-9e47e9bf85-21df579532.zip/node_modules/jotai/esm/react.mjs"],"sourcesContent":["import ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\n\nconst StoreContext = createContext(void 0);\nconst useStore = (options) => {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nconst Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = useRef();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = ReactExports.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n    throw promise;\n  }\n});\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  return isPromiseLike(value) ? use(value) : value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}